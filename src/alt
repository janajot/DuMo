//old way to determine h and i
        final double ax = getWidth() / (double) (DuMo.Game.boardX * 2);
        final double ay = getHeight() / (double) (DuMo.Game.boardY * 2);
        final double bx = ax;
        final double by = -ay;

        double a = (DuMo.Main.mouseX - bx * DuMo.Main.mouseY / by) / (ax - bx * ay / by);
        double b = (DuMo.Main.mouseX - ax * DuMo.Main.mouseY / ay) / (bx - ax * by / ay);
        int aI = (int) Math.floor(a);
        int bI = (int) Math.floor(b);

        DuMo.Main.gH = aI - bI - 1;
        DuMo.Main.gI = aI - DuMo.Main.gH / 2 - 1;

        System.out.println("gH = " + DuMo.Main.gH);
        System.out.println("gI = " + DuMo.Main.gI);

TODO---------------------------------------------------------------- NEW ALT THING BEGINS HERE


import java.util.Arrays;

import static java.awt.event.KeyEvent.*;

public class DuMo.Game {
    public static int boardX;
    public static int boardY;
    public static int boardH;
    public static int boardHI;
    public static int boardVI;
    public static DuMo.piece.Piece[][] board;
    public static DuMo.piece.Piece curPiece = new DuMo.piece.kyap.PieceKyap((byte) 0b0_0_000000);
    public static byte[][] edgeStatus;

    //Listener
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    public static void onClick() {
        if (DuMo.Main.isDisplayHovered) {
            if (DuMo.Main.rightBtn) {
                curPiece.getNext();
            }
            if (DuMo.Main.leftBtn && isValid(DuMo.Main.gH, DuMo.Main.gI)) {
                place(curPiece.clone(), DuMo.Main.gH, DuMo.Main.gI);
            }
            if (DuMo.Main.middleBtn) {
                remove(DuMo.Main.gH, DuMo.Main.gI);
            }
        }
    }

    //Board manipulation
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    private static void setInvalid(int h, int i) {
        if (isOutOfBounds(h, i)) return;
        getPiece(h, i).setInvalid();
        System.out.print("i ");
        HI(h, i);
    }

    private static void setValidated(int h, int i) {
        if (isOutOfBounds(h, i)) return;
        getPiece(h, i).setValidated();
        System.out.print("v ");
        HI(h, i);
    }

    private static void setEmpty(int h, int i) {
        if (isOutOfBounds(h, i)) return;
        getPiece(h, i).setEmpty();
    }

    public static void place(DuMo.piece.Piece piece, int h, int i) {
        boolean wasPiece = isPiece(h, i);
        if (isValid(h, i)) {
            board[h][i] = piece;
            if (!wasPiece)
                if (isHorizontal(h)) {
                    setInvalid(h, i - 1);
                    setInvalid(h + 1, i);
                    setInvalid(h + 1, i + 1);
                    setInvalid(h, i + 1);
                    setInvalid(h - 1, i + 1);
                    setInvalid(h - 1, i);
                } else {
                    setInvalid(h + 2, i);
                    setInvalid(h + 1, i);
                    setInvalid(h - 1, i);
                    setInvalid(h - 2, i);
                    setInvalid(h - 1, i - 1);
                    setInvalid(h + 1, i - 1);
                }
        }
    }

    public static void remove(int h, int i) {
        if (isOutOfBounds(h, i)) return;
        if (getPiece(h, i).isPiece()) {
            setEmpty(h, i);
            if (isHorizontal(h)) {
                setValidated(h, i + 1);
                setValidated(h, i - 1);
                setValidated(h - 1, i + 1);
                setValidated(h - 1, i);
                setValidated(h + 1, i + 1);
                setValidated(h + 1, i);
            } else {
                setValidated(h + 1, i);
                setValidated(h + 1, i - 1);
                setValidated(h + 2, i);
                setValidated(h - 1, i);
                setValidated(h - 1, i - 1);
                setValidated(h - 2, i);
            }
        }
    }

    public static void resetBoard() {
        boardH = boardY * 2 - 1;
        boardHI = boardX - 1;
        boardVI = boardX;
        board = new DuMo.piece.Piece[boardH][];
        for (int h = 0; h < boardH; h += 2) {
            board[h] = new DuMo.piece.Piece[boardHI];
            Arrays.fill(board[h], new DuMo.piece.kyap.PieceKyap((byte) 0b0_1_000000));
        }
        for (int h = 1; h < boardH; h += 2) {
            board[h] = new DuMo.piece.Piece[boardVI];
            Arrays.fill(board[h], new DuMo.piece.kyap.PieceKyap((byte) 0b0_1_000000));
        }

        edgeStatus = new byte[boardH][];
        for (int h = 0; h < boardH; h += 2) {
            edgeStatus[h] = new byte[boardHI];
            Arrays.fill(edgeStatus[h], (byte) 0b1000000);
        }
        for (int h = 1; h < boardH; h += 2) {
            edgeStatus[h] = new byte[boardVI];
            Arrays.fill(edgeStatus[h], (byte) 0b1000000);
        }
    }

    //Board checks
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    private static boolean isOutOfBounds(int h, int i) {
        return h >= boardH ||
                i >= (isHorizontal(h) ?
                        boardHI :
                        boardVI) ||
                h < 0 ||
                i < 0;
    }

    public static boolean isHorizontal(int h) {
        return (h & 1) == 0;
    }

    public static boolean isValid(int h, int i) {
        if (isOutOfBounds(h, i)) return false;
        HI(h, i);
        ((DuMo.piece.kyap.PieceKyap)getPiece(h, i)).printState();
        return getPiece(h, i).isValid();
    }

    public static boolean isInvalid(int h, int i) {
        if (isOutOfBounds(h, i)) return false;
        return getPiece(h, i).isInvalid();
    }

    public static boolean isPiece(int h, int i) {
        if (isOutOfBounds(h, i)) return false;
        return getPiece(h, i).isPiece();
    }

    public static void getEdgeStatus() {
        for (int h = 0; h < DuMo.Game.boardH; h += 2)
            for (int i = 0; i < DuMo.Game.boardHI; i++) {
                byte right = getEdgeOnPositiveI(h, i);
                byte left = getEdgeOnNegativeI(h, i);
                edgeStatus[h][i] = right == left ?
                        left :
                        left == DuMo.piece.Piece.EDGE_NONE ?
                                right :
                                right == DuMo.piece.Piece.EDGE_NONE ?
                                        left :
                                        DuMo.piece.Piece.EDGE_INVALID;
            }

        for (int h = 1; h < DuMo.Game.boardH; h += 2)
            for (int i = 0; i < DuMo.Game.boardVI; i++) {
                byte upper = getEdgeOnPositiveH(h, i);
                byte lower = getEdgeOnNegativeH(h, i);
                edgeStatus[h][i] = upper == lower ?
                        lower :
                        lower == DuMo.piece.Piece.EDGE_NONE ?
                                upper :
                                upper == DuMo.piece.Piece.EDGE_NONE ?
                                        lower :
                                        DuMo.piece.Piece.EDGE_INVALID;
            }
    }

    private static byte getEdgeOnPositiveH(int h, int i) {
        return isPiece(h + 1, i - 1) ?
                board[h + 1][i - 1].getEdgeUnchecked(4) :
                isPiece(h + 2, i) ?
                        board[h + 2][i].getEdgeUnchecked(3) :
                        isPiece(h + 1, i) ?
                                board[h + 1][i].getEdgeUnchecked(5) :
                                DuMo.piece.Piece.EDGE_NONE;
    } //Axis Unchecked!

    private static byte getEdgeOnNegativeH(int h, int i) {
        return isPiece(h - 1, i - 1) ?
                board[h - 1][i - 1].getEdgeUnchecked(2) :
                isPiece(h - 2, i) ?
                        board[h - 2][i].getEdgeUnchecked(0) :
                        isPiece(h - 1, i) ?
                                board[h - 1][i].getEdgeUnchecked(1) :
                                DuMo.piece.Piece.EDGE_NONE;
    } //Axis Unchecked!

    private static byte getEdgeOnPositiveI(int h, int i) {
        return isPiece(h - 1, i + 1) ?
                board[h - 1][i + 1].getEdgeUnchecked(5) :
                isPiece(h, i + 1) ?
                        board[h][i + 1].getEdgeUnchecked(0) :
                        isPiece(h + 1, i + 1) ?
                                board[h + 1][i + 1].getEdgeUnchecked(4) :
                                DuMo.piece.Piece.EDGE_NONE;
    } //Axis Unchecked!

    private static byte getEdgeOnNegativeI(int h, int i) {
        return isPiece(h - 1, i) ?
                board[h - 1][i].getEdgeUnchecked(1) :
                isPiece(h, i - 1) ?
                        board[h][i - 1].getEdgeUnchecked(3) :
                        isPiece(h + 1, i) ?
                                board[h + 1][i].getEdgeUnchecked(2) :
                                DuMo.piece.Piece.EDGE_NONE;
    } //Axis Unchecked!

    public static DuMo.piece.Piece getPiece(int h, int i) {
        if (isOutOfBounds(h, i)) return new DuMo.piece.kyap.PieceKyap((byte) 0b1_0_000000);
        return getPiece(h, i);
    }

    //Other manipulation
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    public static void invertCurrent() {
        curPiece.invert();
    }

    public static void rotateCurrentLeft() {
        curPiece.rotateLeft();
    }

    public static void rotateCurrentRight() {
        curPiece.rotateRight();
    }

    //to do remove
    private static void HI(int h, int i) {
        System.out.println("--- " + c++ + " ---");
        System.out.println("h: " + h);
        System.out.println("i: " + i);
    }
    private static int c = 0;
}

TODO---------------------------------------------------------------- NEW ALT THING BEGINS HERE

        public class Test {
            public static void main(String[] args) {
                double aX = -1;
                double aY = 1;
                double bX = 1;
                double bY = 1;
                double x = 2;
                double y = 0;

                System.out.println(getb(aX, aY, bX, bY, x, y));
                System.out.println(geta(aX, aY, bX, bY, x, y));

                byte i = (byte) 0b10000000;
                i--;
                System.out.println(Integer.toBinaryString(i));
            }

            private static double getb(double ax, double ay, double bx, double by, double x, double y) {
                return (x - ax * y / ay) / (bx - ax * by / ay);
            }

            private static double geta(double ax, double ay, double bx, double by, double x, double y) {
                return (x - bx * y / by) / (ax - bx * ay / by);
            }


        }

TODO---------------------------------------------------------------- NEW ALT THING BEGINS HERE