package DuMo.board;

import DuMo.piece.Piece;

import java.util.Map;
import java.util.Optional;
import java.util.TreeMap;

/**
 * An implementation of the {@link Board} interface
 * that is has an infinite(" ") canvas size. Is optimized
 * for having very little pieces and a lot of free space
 * on immense visible boards. placing and removing run in O(log(n))
 * time, where n is the number of pieces in a row. ForEach
 * runs in O(n*log(n)). The advantage of this is that
 * huge, sparsely filled boards can be rendered easily,
 * because not every index has to be checked.
 * @see DuMo.board.Board
 * @see DesertedDynamicBoard
 */
public class DesertedDynamicBoard implements Board {
    private int scopeX;
    private int scopeY;
    private int offsetX;
    private int offsetY;
    private boolean enforceScope;

    private final TreeMap<Integer, TreeMap<Integer, Piece>> board;

    public DesertedDynamicBoard(int scopeX, int scopeY) {
        this.scopeX = scopeX;
        this.scopeY = scopeY;
        this.offsetX = 0;
        this.offsetY = 0;
        this.enforceScope = true;
        board = new TreeMap<>();
    }

    @Override
    public int getBoardX() {
        return scopeX;
    }

    @Override
    public int getBoardY() {
        return scopeY;
    }

    @Override
    public Optional<Piece> place(Piece piece, int h, int i) {
        Piece prev = null;
        if (isValid(h, i)) {
            tryToAdd(h);
            prev = board.get(h).put(i, piece);
        }
        return prev == null ? Optional.empty() : Optional.of(prev);
    }

    @Override
    public Optional<Piece> remove(int h, int i) {
        Piece prev = null;
        if (isPiece(h, i)) {
            prev = board.get(h).remove(i);
            tryToRemove(h);
        }
        return prev == null ? Optional.empty() : Optional.of(prev);
    }

    @Override
    public void resetBoard() {
        board.clear();
    }

    @Override
    public boolean isValid(int h, int i) {
        if (isOutOfBounds(h, i)) return false;
        //check for surrounding tiles to be empty
        if (Board.isHorizontal(h)) {
            //indices to be checked:
            // 1) h     | i - 1, i + 1;
            // 2) h - 1 | i,     i + 1;
            // 3) h + 1 | i,     i + 1;
            Map<Integer, Piece> map0 = board.get(h);
            Map<Integer, Piece> map1 = board.get(h - 1);
            Map<Integer, Piece> map2 = board.get(h + 1);
            return !(map0 == null || map1 == null || map2 == null ||
                    map0.containsKey(i - 1) || map0.containsKey(i + 1) ||
                    map1.containsKey(i) || map1.containsKey(i + 1) ||
                    map2.containsKey(i) || map2.containsKey(i + 1));
        }
        //indices to be checked:
        // 1) h - 1 | i - 1, i
        // 2) h + 1 | i - 1, i
        // 3) h - 2 | i
        // 4) h + 2 | i
        Map<Integer, Piece> map0 = board.get(h - 1);
        Map<Integer, Piece> map1 = board.get(h + 1);
        Map<Integer, Piece> map2 = board.get(h - 2);
        Map<Integer, Piece> map3 = board.get(h + 2);
        return !(map0 == null || map1 == null || map2 == null || map3 == null ||
                map0.containsKey(i - 1) || map0.containsKey(i) ||
                map1.containsKey(i - 1) || map1.containsKey(i) ||
                map2.containsKey(i) ||
                map3.containsKey(i));
    }

    @Override
    public boolean isInvalid(int h, int i) {
        return !isValid(h, i);
    }

    @Override
    public boolean isPiece(int h, int i) {
        Optional<Piece> piece = getPiece(h, i);
        return piece.isPresent() && piece.get().isPiece();
    }

    @Override
    public boolean isNoPiece(int h, int i) {
        if (isOutOfBounds(h, i)) return false;
        Optional<Piece> piece = getPiece(h, i);
        return piece.isEmpty() || !piece.get().isPiece();
    }

    /**
     * Checks whether a given piece slot is out of scope,
     * if placing out of view is disallowed
     *
     * @param h the height of the piece slot
     * @param i the index of the piece slot
     * @return Whether any part of a Piece that would be
     * placed in the given piece slot would reach outside
     * the current scope, or always false if checking for
     * out-of-scope is disabled
     */
    @Override
    public boolean isOutOfBounds(int h, int i) {
        return enforceScope && (
                h < offsetY << 1
                        || h >= (scopeY + offsetY) << 1
                        || i < offsetX
                        || i > (Board.isHorizontal(h) ?
                        scopeX - 1 + offsetX :
                        scopeX + offsetX)
        );
    }

    @Override
    public byte[][] getEdgeStatus() {
        return new byte[0][];
    }

    @Override
    public Optional<Piece> getPiece(int h, int i) {
        Map<Integer, Piece> atH = board.get(h);
        if (atH == null) return Optional.empty();
        Piece p = atH.get(i);
        return p == null ? Optional.empty() : Optional.of(p);
    }

    /**
     * Checks whether the given tile is Filled or not, and if so, returns where.
     * If scope enforcing is enabled, {@link Board#OOB} can be returned.
     * @inheritDoc
     * @see #isOutOfBounds
     */
    @Override
    public int whereIsTileFilled(int x, int y) {
            int h = y * 2 + 1;
            //i = x
            if (enforceScope && (x >= scopeX + offsetX || y >= scopeY + offsetY || x < offsetX || y < offsetY)) return OOB;
            return isPiece(h, x) ? DOWN :
                    isPiece(h - 1, x) ? RIGHT :
                            isPiece(h - 2, x) ? UP :
                                    isPiece(h - 1, x - 1) ? LEFT :
                                            EMPTY;
    }

    /**
     * @inheritDoc
     * @see #forEachPieceInScope()
     */
    @Override
    public void forEachPiece(PieceConsumer action) {
        board.forEach((h, map) -> {
            map.forEach((i, piece) -> {
                action.accept(piece, h, i);
            });
        });
    }

    @Override
    public void forEachHorizontalPiece(PieceConsumer action) {

    }

    @Override
    public void forEachVerticalPiece(PieceConsumer action) {

    }

    /**
     * @see Board#forEachPiece
     */
    public void forEachPieceInScope() {
        Map.Entry<Integer, TreeMap<Integer, Piece>> e = board.ceilingEntry(offsetY << 1);
        while (e != null && e.getKey() <= (scopeY + offsetY) << 1) {
            break;
            //TODO
        }
    }

    public void panX(int offset) {
        offsetX += offset;
    }

    public void panY(int offset) {
        offsetY += offset;
    }

    public void setScope(int x, int y) {
        scopeX = x;
        scopeY = y;
    }

    public int getPosX() {
        return offsetX;
    }

    public int getPosY() {
        return offsetY;
    }

    public int getScopeX() {
        return scopeX;
    }

    public int getScopeY() {
        return scopeY;
    }

    @Override
    public boolean[] getFilledTiles() {
        return new boolean[0];
    }

    private void tryToAdd(int h) {
        if (!isPresent(h))
            board.put(h, new TreeMap<>());
    }

    private void tryToRemove(int h) {
        Map<?, ?> atH = board.get(h);
        if (atH != null && atH.isEmpty())
            board.remove(h);
    }

    private boolean isPresent(int h) {
        return board.containsKey(h);
    }
}
